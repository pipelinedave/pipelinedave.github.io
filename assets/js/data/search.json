[ { "title": "K3s, GitOps, and AI: My Copilot-Powered Cluster Management", "url": "/2025/", "categories": "kubernetes, gitops, flux, copilot, automation, devops, k3s", "tags": "kubernetes, k3s, gitops, flux, copilot, ai, automation, devops, cluster-management", "date": "2025-05-17 11:00:00 +0200", "snippet": "Managing Kubernetes clusters, even a relatively streamlined one like k3s, can often feel like a juggling act. There are manifests to write, configurations to track, deployments to verify, and the e...", "content": "Managing Kubernetes clusters, even a relatively streamlined one like k3s, can often feel like a juggling act. There are manifests to write, configurations to track, deployments to verify, and the ever-present challenge of keeping documentation in sync with reality. For a while now, I‚Äôve been on a journey to refine my k3s cluster management, and I‚Äôm thrilled to share a setup that has truly transformed my workflow: a GitOps-centric approach supercharged by GitHub Copilot.My entire cluster configuration lives in my k3s-config repository, which you can explore to see these principles in action.The Foundation: GitOps with FluxCDAt the heart of my strategy is a steadfast commitment to GitOps. For me, this means the k3s-config Git repository is the single source of truth. If it‚Äôs not in the repo, it doesn‚Äôt (or shouldn‚Äôt) exist in the cluster. FluxCD is the diligent operator that makes this happen, continuously reconciling the state of my cluster with what‚Äôs defined in the main branch.This provides a solid baseline: Version Control for Infrastructure: Every change is a commit, auditable and revertible. Consistency: What you see in Git is what you get in the cluster. Automation: Flux handles the deployment pipeline automatically.But even with this robust foundation, the manual effort of creating, updating, and documenting configurations can be significant. That‚Äôs where my AI assistant steps in.The Supercharger: GitHub Copilot Joins the FrayIntegrating GitHub Copilot into my daily operations has been nothing short of a game-changer. It‚Äôs not just about code completion; it‚Äôs about having an intelligent partner that understands my specific context, patterns, and even my documentation needs.Here‚Äôs how Copilot elevates my GitOps workflow:1. Accelerated Development and Manifest CreationWriting YAML can be tedious and error-prone. Copilot, armed with the context of my repository (including my cluster-context.md which outlines my specific conventions), significantly speeds this up. Smart Manifest Generation: Need a new Deployment, Service, or Ingress? Copilot can draft it based on a simple prompt, often correctly inferring details like application names and port numbers. Adherence to Standards: I have critical protection policies, like ensuring all PersistentVolumeClaims (PVCs) include the kubernetes.io/pvc-protection finalizer and that all Ingresses follow my app-name.stillon.top domain schema with letsencrypt-prod issuer. Copilot helps me remember and implement these by suggesting the correct snippets or even modifying existing manifests to include them. Flux Kustomizations: Creating the Kustomization resources in my apps/ directory to tell Flux about new applications is also streamlined. Copilot knows the structure and can generate the necessary YAML quickly.2. Living, Breathing DocumentationThis is perhaps one of the most remarkable aspects. I‚Äôve established an ‚ÄúAuto-Documentation Update‚Äù process where Copilot plays a key role. When I make significant changes or explicitly ask, Copilot helps me: Update Application Lists: It can scan my apps/ and apps-incomplete/ directories and update the ‚ÄúFully Managed Applications‚Äù and ‚ÄúPartially Managed Applications‚Äù sections in my documentation. Verify Repository Structure: It helps ensure my documented repository structure matches reality. Keep Key Scripts Documented: New scripts in scripts/ or changes to existing ones? Copilot assists in updating their descriptions.This means my docs/README.md and the crucial cluster-context.md (which Copilot itself uses for context!) stay remarkably up-to-date. It‚Äôs like having a dedicated technical writer who‚Äôs also an expert on my system.3. Intelligent Cluster Interaction via MCP ToolsThrough Model Context Protocol (MCP) tools, Copilot can directly (but safely) interact with my cluster for verification and troubleshooting. Instead of me manually running a series of kubectl or flux commands, I can ask Copilot: ‚ÄúAre all pods running in the choremane-prod namespace?‚Äù (Uses bb7_pods_list_in_namespace) ‚ÄúWhat‚Äôs the status of the docspell Kustomization in Flux?‚Äù (Uses bb7_get_kubernetes_resources) ‚ÄúShow me the recent logs for the linkding pod.‚Äù (Uses bb7_pods_log)If something seems off, Copilot can even suggest reconciliation commands or help pinpoint issues by analyzing resource statuses.4. Guardian of Best PracticesMy workflow has specific manual steps, like creating namespaces with kubectl create namespace &lt;namespace&gt; before Flux tries to deploy to them (a crucial step to protect PVCs). Copilot consistently reminds me of these nuances. Similarly, when handling sensitive data, it guides me through the SealedSecrets workflow: create locally, use kubeseal, commit the sealed version, and delete the original.A Peek Inside My k3s-config RepositoryMy repository structure is designed to support this workflow: kustomize/ and kustomize-incomplete/: Contain the actual Kubernetes manifests. apps/ and apps-incomplete/: House the Flux Kustomization CRDs that point to the manifest directories. flux-system/: Holds the Flux bootstrap configuration. docs/: The comprehensive documentation hub, co-maintained by me and Copilot. scripts/: Utility scripts, often for tasks that bridge manual steps and GitOps.This clear separation of concerns makes it easy for both humans and Copilot to navigate and understand the configuration.The Payoff: Tangible BenefitsAdopting this Copilot-enhanced GitOps model has yielded significant advantages: Increased Speed: Repetitive tasks are automated or significantly sped up. Improved Consistency: Adherence to my standards is much higher. Reduced Errors: Fewer typos or forgotten critical configurations in my YAML. Truly Up-to-Date Documentation: This alone is a massive win. Empowered Me: Complex Kubernetes operations become more accessible with an AI assistant ready to guide and explain. Enhanced Learning: Copilot often shows me efficient ways to achieve tasks or reminds me of commands and configurations, acting as an interactive learning tool.Looking AheadMy journey with k3s, GitOps, Flux, and now GitHub Copilot has been incredibly rewarding. It feels like I‚Äôm at the forefront of a new era in operations, where AI doesn‚Äôt just assist with code but becomes an integral part of managing complex systems. The k3s-config repository is a living testament to this synergy.If you‚Äôre managing Kubernetes, I highly encourage you to explore how a GitOps foundation, coupled with the intelligence of tools like GitHub Copilot, can revolutionize your workflows. It certainly has for me!" }, { "title": "Introducing the Copilot Todo System: A Hands-Off Task Manager", "url": "/2025/", "categories": "productivity, tools, github", "tags": "copilot, automation, task management, developer tools", "date": "2025-05-08 00:00:00 +0200", "snippet": "Streamlining Developer Workflow with the Copilot Todo SystemAs developers, we constantly juggle ideas, bug fixes, and feature requests while working on projects. Often, these ideas strike us at the...", "content": "Streamlining Developer Workflow with the Copilot Todo SystemAs developers, we constantly juggle ideas, bug fixes, and feature requests while working on projects. Often, these ideas strike us at the most inconvenient times: mid-task, during debugging, or when implementing a feature. To address this chaotic yet inevitable part of the creative process, I‚Äôve built the Copilot Todo System.This system, which you can find in the Copilot Todo System Template repository, is designed to bring order to the chaos by leveraging GitHub Copilot as your task management assistant.The Problem: Too Many Unorganized IdeasIn my daily workflow, I often encounter: Ideas for new features while working on unrelated tasks Bugs and issues that need fixing but not immediately Performance improvements or maintenance tasks that are low priorityThe result? A cluttered list of bullet points in a markdown file, sticky notes, or worse‚Äîmental overload. I needed a hands-off solution to manage this without interrupting my flow.The Solution: Automated Organization with CopilotThe Copilot Todo System is a simple yet powerful task management approach. Here‚Äôs how it works: A Centralized Todo File: All ideas, issues, bugs, and tasks are added to a single .github/copilot/Todo.md file. Automatic Organization: Every time I mention ‚Äútodo‚Äù in a Copilot chat, it parses the file, formalizes tasks, and organizes them into categories and priorities. Hands-Off Updates: I can keep adding bullet points anywhere in the file, and Copilot will ensure the file remains clean, structured, and actionable. Intelligent Suggestions: Copilot reviews the tasks, prioritizes them, and even suggests the next best task to tackle.How It WorksThe repository includes a sample structure for .github/copilot/Todo.md and instructions for Copilot to follow. Here‚Äôs a quick overview of the setup:Todo File Example# Project Todo List## Inbox- Add dark mode to the dashboard- Fix login bug when user uses special characters## Organized Tasks### High Priority- Fix login bug when user uses special characters (#security)### Medium Priority- Add dark mode to the dashboard (#feature)## In Progress&lt;!-- Tasks currently being worked on --&gt;## Completed&lt;!-- Finished tasks --&gt;Copilot takes care of moving tasks from the Inbox to the Organized Tasks section, tags them, and ensures everything stays clean and sorted.Instructions for CopilotThe system uses a .github/copilot/CopilotTodo.md file to provide specific guidance on how Copilot should process the Todo file. This ensures consistent behavior and adaptability over time.Getting StartedIf you‚Äôre interested in using this system, head over to the template repository. Clone it, customize the Todo file, and start automating your task management today!Why I Built ThisAs someone who loves automating workflows and minimizing repetitive tasks, this system embodies my philosophy: ‚ÄúLet the tools work for you.‚Äù By offloading the mental overhead of task management to GitHub Copilot, I can focus on coding, creating, and solving problems.Try It Out and Share Your ExperienceI‚Äôd love to hear how this system works for you and what improvements you‚Äôd suggest. Feel free to fork the repository, adapt it to your needs, and let me know your thoughts. Together, we can make task management a breeze for developers everywhere.Happy coding!" }, { "title": "Three-Finger Swipe on Linux: macOS Style!", "url": "/2023/", "categories": "", "tags": "Bash, Scripts, macOS, Touchpad, Swipe, Feature", "date": "2023-09-20 00:00:00 +0200", "snippet": "Three-Finger Swipe on Linux: macOS Style!Man, if you‚Äôre like me, you dig how macOS handles three-finger swipes to switch desktops. It‚Äôs smooth, it‚Äôs cool, it‚Äôs where it‚Äôs at. But what about us Linu...", "content": "Three-Finger Swipe on Linux: macOS Style!Man, if you‚Äôre like me, you dig how macOS handles three-finger swipes to switch desktops. It‚Äôs smooth, it‚Äôs cool, it‚Äôs where it‚Äôs at. But what about us Linux folks? We want in on that action too, right?The IdeaThe jam is simple. On macOS, a three-finger swipe on the trackpad lets you seamlessly switch between virtual desktops. It‚Äôs slicker than a greased-up watermelon, let me tell you. Now, Linux ain‚Äôt natively geared for that, but why should we miss out?The SolutionHold tight, ‚Äòcause this is where the magic happens. We‚Äôre gonna use libinput to catch touchpad events and wmctrl to switch desktops. You dig?Before runnin‚Äô the script, make sure you‚Äôve got wmctrl installed. If not, hit it with:sudo apt-get install wmctrlor if you‚Äôre rollin‚Äô with another package manager, you know the drill.The CodeHere‚Äôs the script in all its glory. Pay attention, ‚Äòcause this is the good stuff.#!/bin/bash# ----------------------------------------------------------------------------# Script Name: three_finger_touchpad_desktop_switch.sh# Description: Switch desktops using a 3-finger swipe gesture# Author: github.com/pipelinedave# Version: 1.1# Usage: sudo sh three_finger_touchpad_desktop_switch.sh# Note: Update the \"device\" variable to point to your actual input device.# ----------------------------------------------------------------------------# Check if wmctrl is installedif ! command -v wmctrl &amp;&gt; /dev/null; thenecho \"Hey, playa! wmctrl ain't installed. Get it via your package manager.\"exit 1fi# Your touchpad device (change to your actual device)device=\"/dev/input/event6\"# Start the loop and capture libinput eventsecho \"Looping...\"libinput debug-events --device $device | while read -r linedo# Looking for 3-finger swipesgesture=$(echo \"$line\" | grep 'GESTURE_SWIPE_UPDATE' | awk '{ print $4 }')if [ \"$gesture\" = \"3\" ]; then# Get the vertical direction of the swipedirection=$(echo \"$line\" | grep 'GESTURE_SWIPE_UPDATE' | awk '{ print $7 }')# If swipe is upif [ -n \"$direction\" ] &amp;&amp; (( $(echo \"$direction &gt; 0\" | bc -l) )); thenecho \"Direction: up\"wmctrl -s 0 # Switch to desktop 0# If swipe is downelif [ -n \"$direction\" ] &amp;&amp; (( $(echo \"$direction &lt; 0\" | bc -l) )); thenecho \"Direction: down\"wmctrl -s 1 # Switch to desktop 1fifidoneThere you have it, folks. Get this script up and running, and you‚Äôll be swiping through your Linux desktops smoother than Barry White‚Äôs vocal cords. Can you dig it?" }, { "title": "Introducing memodawg: A Solution for Managing Long WhatsApp Voice Notes", "url": "/2023/", "categories": "", "tags": "Go, Memoization, Backend, Frontend, WhatsApp Voice Notes, Docker, Kubernetes", "date": "2023-09-17 00:00:00 +0200", "snippet": "Introducing memodawg: A Solution for Managing Long WhatsApp Voice NotesThe Problem: Long WhatsApp Voice NotesThe genesis of memodawg was driven by the cumbersome task of managing long WhatsApp voic...", "content": "Introducing memodawg: A Solution for Managing Long WhatsApp Voice NotesThe Problem: Long WhatsApp Voice NotesThe genesis of memodawg was driven by the cumbersome task of managing long WhatsApp voice notes. Such notes are not only time-consuming to listen to but also tricky to navigate if you want to revisit specific sections.Overviewmemodawg is an innovative platform designed to streamline the experience of handling long voice notes through a process called memoization. Crafted in Go, it provides a performance-optimized, user-friendly way to engage with your voice notes.Project StructureThe project is segmented into two primary components: api: The backend, engineered in Go, serves as the heart of memoization operations for voice notes. It manages audio files, performs the memoization, and returns the processed notes to the frontend. frontend: Also powered by Go, this segment offers a simplified UI to interact with your memoized voice notes. It connects to the backend for all operations and presents a seamless user experience. Each of these components is neatly packed with its own go.mod file, allowing for localized dependency management and version control.How it WorksUpon uploading a voice note to memodawg, the backend takes over and performs memoization. This involves parsing the audio file into smaller, labeled segments for easier navigation. The frontend then allows you to interact with these memoized sections, providing an organized, hassle-free way to engage with long audio messages.Dockerized for DeploymentBoth the backend (api) and frontend are Dockerized, making the application easily deployable and manageable. It encapsulates the environment, ensuring consistency across different stages of deployment.Kubernetes Supportmemodawg also ships with ready-to-use Kubernetes manifests, providing a straightforward path to scale the application in a Kubernetes cluster. This ensures that memodawg is not just a solution for individuals but can be robustly scaled to serve multiple users across various environments.Newest Feature Idea: Azure Quota NotificationsTo add even more value, an upcoming feature aims to offer automatic notifications about your remaining Azure free quota, aiding users in better cloud resource management.Conclusionmemodawg offers a much-needed solution for those weighed down by long, unmanageable WhatsApp voice notes. With its Dockerized architecture and Kubernetes-ready manifests, it is poised for easy deployment and scalability. The project represents a synthesis of modern development practices and real-world utility, making it not just a concept but a practical tool for everyday use." }, { "title": "Building a Cost-Effective, Hassle-Free Website for a Tattoo Studio", "url": "/2023/", "categories": "", "tags": "DevOps, Jekyll, GitHub Pages", "date": "2023-04-22 00:00:00 +0200", "snippet": "The IssueA non-tech-savvy friend of mine recently decided to open a tattoo studio. I offered to build and host a website for his new venture with minimal cost, maintenance, and coding effort. In th...", "content": "The IssueA non-tech-savvy friend of mine recently decided to open a tattoo studio. I offered to build and host a website for his new venture with minimal cost, maintenance, and coding effort. In this post, I‚Äôll share how I set up a mobile-friendly, SEO-optimized, single-scrolling landing page that makes it easy for customers to get in touch and complies with German law.First, I registered the TLD brotherhood.ink, which was available and perfectly suited for a tattoo studio. The site needed to serve as a landing page, featuring a simple contact form, a list of offered services, and owner information. Ideally, the site would also integrate the artist‚Äôs Instagram feed, filtering by specific hashtags to keep content fresh and relevant.The SolutionTo achieve this, I chose GitHub Pages as a free, highly available hosting platform, and Jekyll as a static site generator. I configured the domain‚Äôs DNS to point to GitHub Pages and set up the repository accordingly.I found a free theme that met our requirements: Agency Jekyll Theme. I cloned the theme‚Äôs repository into a ‚Äújekyll‚Äù subfolder within our project root, which simplified the deployment process.Next, I created a Gemfile to list the required Ruby Gems like Jekyll and some additional helpful gems:source 'https://rubygems.org'gem 'jekyll'gem 'jekyll-paginate'gem 'jekyll-sitemap'gem 'jekyll-feed'gem 'jekyll-seo-tag'I also added a GitHub workflow that automates the process of building and deploying the Jekyll site to the gh-pages branch whenever changes are pushed to the main branch or a manual dispatch is triggered. The workflow caches Ruby gems and uses the jekyll-action to build and deploy the site.name: Build and deploy to branch gh-pageson: push: branches: - main workflow_dispatch:jobs: build-and-deploy-jekyll-src-to-branch-gh-pages: runs-on: ubuntu-latest permissions: contents: write steps: - name: üìÇ setup uses: actions/checkout@v3 - name: üéÅ Cache Ruby gems uses: actions/cache@v3 with: path: vendor/bundle key: $-gems-$ restore-keys: | $-gems- - name: üöÄ Build and deploy uses: helaili/jekyll-action@v2 with: token: $ jekyll_src: 'jekyll' target_branch: 'gh-pages' pre_build_commands: 'gem update --system'After configuring the deployment branch and enabling HTTPS, I navigated to https://brotherhood.ink and saw the theme‚Äôs default look. I then replaced the stock content with the actual business information, tweaked the layout, and replaced the header image.ConclusionThere‚Äôs still work to be done, such as integrating the Instagram feed, utilizing the installed Jekyll plugins like jekyll-seo-tag, setting up Google Analytics, configuring a mail server, and more. Stay tuned for updates!Here‚Äôs a list of the technologies utilized: GitHub Pages Jekyll Agency Jekyll Theme Jekyll SEO Tag Jekyll Sitemap Jekyll Feed Jekyll PaginateThis project demonstrates how to create a cost-effective, low-maintenance website using open-source technologies and free hosting services. If you‚Äôre looking for a similar solution, give it a try!" }, { "title": "Understanding GitHub Actions and Ruby Versions for Jekyll: Resolving Compatibility Issues", "url": "/2023/", "categories": "", "tags": "jekyll, github, ruby, github-actions", "date": "2023-04-20 00:00:00 +0200", "snippet": "Author‚Äôs note: I recently encountered an issue with one of my Jekyll projects when using GitHub Actions to build and deploy the site. After some tinkering and research, I discovered how Ruby versio...", "content": "Author‚Äôs note: I recently encountered an issue with one of my Jekyll projects when using GitHub Actions to build and deploy the site. After some tinkering and research, I discovered how Ruby versions are managed in Jekyll projects and GitHub Actions workflows, and how to resolve compatibility issues. I thought I‚Äôd share this knowledge with the community in the hopes it might help someone else.The IssueI was using the helaili/jekyll-action@v2 Jekyll GitHub Action from the marketplace to build and deploy my site, and I came across an error in my workflow:env: can't execute 'ruby-2.7': No such file or directoryLater, after some adjustments, I encountered another error:sass-embedded-1.62.0-x86_64-linux-musl requires rubygems version &gt;= 3.3.22,which is incompatible with the current version, 3.1.6The SolutionTo fix the compatibility issue with the sass-embedded gem, I used the pre_build_commands option of the helaili/jekyll-action@v2 action to update RubyGems before building the site. Here‚Äôs my final, working GitHub Actions workflow:name: Build and deploy jekyll siteon: push: branches: - main workflow_dispatch:jobs: jekyll: runs-on: ubuntu-latest permissions: contents: write steps: - name: üìÇ setup uses: actions/checkout@v3 - name: üéÅ Cache Ruby gems uses: actions/cache@v2 with: path: vendor/bundle key: $-gems-$ restore-keys: | $-gems- - name: üöÄ Build and deploy uses: helaili/jekyll-action@v2 with: token: $ jekyll_src: 'jekyll' target_branch: 'gh-pages' pre_build_commands: 'gem update --system'The key addition to the workflow is the pre_build_commands option:pre_build_commands: 'gem update --system'This command updates RubyGems to the latest version before building the site, which resolves the compatibility issue with the sass-embedded gem.ConclusionUnderstanding how Ruby versions and dependencies are managed in Jekyll projects and GitHub Actions workflows, and how to use the pre_build_commands option, helped me fix the issues I encountered and allowed me to continue building and deploying my site smoothly. I hope this post provides some insight for others who may face similar issues. Happy coding!" } ]
